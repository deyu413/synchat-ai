-- Create analyzed_conversation_topics table
CREATE TABLE public.analyzed_conversation_topics (
    topic_id BIGSERIAL PRIMARY KEY,
    client_id UUID NOT NULL REFERENCES public.synchat_clients(client_id) ON DELETE CASCADE,
    topic_name TEXT NOT NULL,
    -- cluster_id can be used to group multiple similar topic_names if the clustering algorithm produces hierarchical or grouped results.
    -- For simple K-Means, this might just be the cluster number or a generated UUID for the cluster.
    cluster_id TEXT,
    example_queries JSONB, -- Store a few example user_queries that fall into this topic
    query_count INTEGER DEFAULT 0,
    -- last_calculated_at indicates when this topic was last processed or updated by the analysis job.
    last_calculated_at TIMESTAMPTZ DEFAULT now(),
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Add indexes
CREATE INDEX idx_analyzed_topics_client_id ON public.analyzed_conversation_topics(client_id);
CREATE INDEX idx_analyzed_topics_topic_name ON public.analyzed_conversation_topics(topic_name);
CREATE INDEX idx_analyzed_topics_cluster_id ON public.analyzed_conversation_topics(cluster_id);

-- RLS Policies (Basic - adjust as needed for actual access patterns by backend services/edge functions)
ALTER TABLE public.analyzed_conversation_topics ENABLE ROW LEVEL SECURITY;

-- Allow service_role to perform all operations (for backend processing jobs)
CREATE POLICY "Allow service_role full access to analyzed topics"
ON public.analyzed_conversation_topics
FOR ALL
TO service_role
USING (true)
WITH CHECK (true);

-- Allow authenticated users (client admins) to read topics for their client_id
-- This assumes a way to link auth.uid() to a client_id and a role, similar to other tables.
-- If client_users table is not used, this policy needs adjustment.
-- For now, this is a placeholder, as actual access will be via backend API.
CREATE POLICY "Allow client admins to read their topics"
ON public.analyzed_conversation_topics
FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1
        FROM public.synchat_clients sc -- Assuming direct link or via a client_users table
        WHERE sc.client_id = analyzed_conversation_topics.client_id
        -- AND sc.admin_user_id = auth.uid() -- This is a guess, depends on synchat_clients schema
        -- OR EXISTS ( SELECT 1 FROM client_users cu WHERE cu.client_id = analyzed_conversation_topics.client_id AND cu.user_id = auth.uid() AND cu.role = 'admin')
        -- For simplicity, if req.user.client_id is primary identifier from middleware:
        AND analyzed_conversation_topics.client_id = (SELECT u.raw_user_meta_data->>'client_id' FROM auth.users u WHERE u.id = auth.uid())::uuid
        -- The above line is an example if client_id is stored in auth.users.raw_user_meta_data
        -- This RLS will likely be primarily for service roles and backend access rather than direct client queries.
        -- The API itself will enforce client access.
    )
);

COMMENT ON TABLE public.analyzed_conversation_topics IS 'Stores topics identified from conversation analysis, typically via query clustering and LLM labeling.';
COMMENT ON COLUMN public.analyzed_conversation_topics.topic_id IS 'Unique identifier for the topic.';
COMMENT ON COLUMN public.analyzed_conversation_topics.client_id IS 'Identifier of the client to whom this topic analysis belongs.';
COMMENT ON COLUMN public.analyzed_conversation_topics.topic_name IS 'Human-readable name for the identified topic/cluster (e.g., generated by an LLM).';
COMMENT ON COLUMN public.analyzed_conversation_topics.cluster_id IS 'Identifier for the cluster this topic belongs to, if applicable.';
COMMENT ON COLUMN public.analyzed_conversation_topics.example_queries IS 'JSON array of sample user queries that fall under this topic.';
COMMENT ON COLUMN public.analyzed_conversation_topics.query_count IS 'Number of queries associated with this topic in the last calculation.';
COMMENT ON COLUMN public.analyzed_conversation_topics.last_calculated_at IS 'Timestamp of when this topic data was last generated or updated.';
COMMENT ON COLUMN public.analyzed_conversation_topics.created_at IS 'Timestamp of when this topic entry was first created.';
